# 作用域和闭包
> 变量是所有编程语言中都具备的最基本的功能了，变量可以储存值，并在之后可以对值进行设置或修改，这是这种储存和访问变量的能力将 **状态** 带给了程序，没有了状态，那么程序就完成不了一些重要的事情了。这里就产生了一个问题，既然变量这么重要，那么它存储在哪儿呢？程序需要的时候该怎么找到它呢？

## 一、关于作用域
于是，就需要一套设计良好的规则来存储变量，以方便之后可以快速的找到这些变量，而这套规则我们称之为 **作用域**。

### 编译原理
JavaScript其实是一门编译语言，虽然平常我们都认为其为动态（如Python）或解释型语言。要理解这一说法，我们需要先理解传统编译语言的编译流程。

* 分词/词法分析 将字符串分析成一个个有意义的语法单元
* 解析/语法分析 将这些语法单元转换成表示程序语法结构的树，即抽象语法树（AST）
* 代码生成 将AST转换成可执行的代码

而JavaScript的编译甚至比这更为复杂，引擎会在语法分析和代码生成前对运行性能进行优化，在代码执行前，对其进行编译。

### 理解作用域
前面我们给出了作用域的定义，要详细理解，我们需要将 **引擎**，**编译器**，**作用域**三者联系起来进行分析。

第一步，在当一段代码在被执行前，如`var a = 2`,编译器会对其进行编译，在代码生成阶段，它会执行两个操作。首先，遇到var a，编译器会询问作用域是否已经有存在同一个作用域中的变量a，若已存在，编译器忽略声明，若不存在，则编译器进行变量 **声明**；其次，为引擎生成运行时代码。

随后，引擎执行编译过程中第二步生成的代码，来对变量a进行查找判断是否已经声明，这个过程由作用域进行协助，查找分为两类，**LHS查询**和 **RHS查询**，LHS查询表示查询某个变量的值并对其进行赋值，RHS查询表示查询某个变量的值。

正如前面介绍过的，作用域是根据名称查找变量的一套规则，在引擎查询的过程中，可能会在当前作用域查询不到所要查询的变量，因此，引擎会在外层嵌套的作用域中继续查找（只能由内向外，不能由外向内查找），直到找到变量或抵达最外层的作用域。

在引擎无法在所有作用域找到目标变量时，就会抛出异常。当引擎是RHS查询时，抛出ReferenceError；当引擎是LHS查询时，非严格模式下在全局作用域中会创建一个目标变量。

### 作用域的工作模型之一————词法作用域
作用域的工作模型有两种，一种是 **词法作用域**，另一种则是 **动态作用域**。其中this采用了动态作用域的工作模型，而一般我们讨论的作用域则都是属于词法作用域的范畴内。

词法作用域就是定义在词法阶段的作用域。简单的说，就是在变量和作用域在书写阶段存在何处位置，那么词法分析器就会保持作用域在那个位置。作用域查找的特点是按照层级向上的方式进行查找，这里就会产生一个“遮蔽效应”，下层作用域同名的变量值遮蔽上层作用域同名的变量值。

通常情况下，只有函数才能生成作用域，但后面将介绍几种“块作用域”的作用域形式。无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置所决定。

#### 欺骗词法
词法作用域的方式完全是由书写时就定义了作用域，那么有没有一种方式可以在运行时对作用域进行修改呢？

1、**eval()**函数接收一个字符串作为参数，并将其中的内容视为书写时就存在于程序中这个位置的代码，这样看起来似乎就达到了运行时动态改变作用域的目的，和下面介绍的其它方式一样，这些欺骗引擎的方式都会造成性能的下降。同时，eval()还有很大的安全风险。（setTimeout和setInterval也是如此）。

2、**with**通常被当做重复引用同一个对象中的多个属性的快捷方式。比如:
```javascript
var obj = {
    a: 1,
    b: 2,
    c: 3
};
//普通方式
obj.a = 2;
obj.b = 3;
obj.c = 4;

//with方式
with(obj){
    a = 3;
    b = 4;
    c = 5;
}
```
而with本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当做作作用域中的标识符来处理，从而创建了一个新的词法作用域。

### 函数作用域和块作用域
我们在上面谈到，除了函数会生成作用域之外，还有块作用域能生成作用域，函数作用域指的是属于这个函数的全部变量都可以在整个函数的范围内使用及复用，这种设计方案能充分利用JavaScript变量可以根据需要改变值类型的动态特性。

作用域能够隐藏内部实现并且规避冲突。

#### 函数作用域
函数分为 **函数声明** 和 **函数表达式** 两种形式，区分二者的最简单方法就是看function关键字，若关键字是声明中第一个词，那么就是一个函数声明，否则就是一个函数表达式。其中，函数声明会被 **提升**，而函数表达式不会。关于提升，还有第二条规则，那就是：函数首先会被提升，然后才是变量。

IIFE，代表立即执行函数表达式，它有三种应用场景。
* 当做函数调用并传递参数进去。
* 解决undefined标识符的默认值被错误覆盖导致的异常。
* 颠倒代码的运行顺序。

#### 块作用域
块作用域是一个用来对最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息。

* with
* try/catch
* let
* const

let和const为ES6新增。要值得注意的是，let进行的声明不会在块作用域中进行提升；let可用于垃圾收集和let循环。

## 二、闭包
首先，我们先对闭包的定义加以了解，YDNJS定义的闭包为：当函数可以记住并访问所在的词法作用域时，就产生了 **闭包**，即使函数是在当前词法作用域之外执行。

先来一个例子，
```javascript
function foo(){
    var a = 2;

    function bar(){
        console.log(a);
    }
    return bar;
}

var baz = foo();
baz(); //结果为2
```

我们试着来理解下，函数bar定义在foo内部，它拥有对它上层作用域foo的引用，因此它能正确查询并输出a的值；函数foo将bar函数作为自己的返回值；在函数foo外的全局作用域中，我们定义变量baz接收foo调用返回的结果即bar函数；调用baz，即调用bar，我们得到2。

这样，我们发现bar函数记住了自己的词法作用域范围，当它不在自己定义的范围内执行时，仍然能够被正常执行，这就是闭包。

正因为闭包会记住自己的内部作用域，依然持有对该作用域的引用，因此垃圾回收器就无法回收该片内存空间。

在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其它的异步（或同步）任务中，只要使用了回调函数，实际上就是在使用闭包。

### 循环和闭包
在for循环中，我们往往会发现打印出来是几个相同的数而不是一个接一个的打印出来，出现这种问题的原因就在我们试图假设循环中的每个迭代在运行时都会给自己捕捉一个i的副本，解决它的办法就是利用闭包。

* IIFE方式
* let方式

以上两种方式利用闭包和块作用域都正确解决了问题。

此外，JS中模块模式也用到了闭包，展现了闭包强大的力量。
